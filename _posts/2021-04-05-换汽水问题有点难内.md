---
title: 换汽水问题
date: 2022-04-05 23:00:00 +0800
categories: [随笔]
tags: [生活]
pin: true
author: 越越

toc: true
comments: true
typora-root-url: ../../lingyuyeah.github.io
math: false
mermaid: true
---

# 换汽水问题 

这是题目：“某商店规定：三个空汽水瓶可以换一瓶汽水。小张手上有十个空汽水瓶，她最多可以换多少瓶汽水喝？”答案是5瓶，方法如下：先用9个空瓶子换3瓶汽水，喝掉3瓶满的，喝完以后4个空瓶子，用3个再换一瓶，喝掉这瓶满的，这时候剩2个空瓶子。然后你让老板先借给你一瓶汽水，喝掉这瓶满的，喝完以后用3个空瓶子换一瓶满的还给老板。如果小张手上有*n*个空汽水瓶，最多可以换多少瓶汽水喝？

（网站把这个归类为难题，但我感觉应该是简单题）



传统法是每次换到的瓶子记n，而下一波能换的瓶子记为q，m是n的累加，q就是上一轮的q减去n的三倍加上n，而最后如果能换的瓶子是2，就额外加1。

我的方法是每次换到的瓶子记n，这一波剩下的记为a，q是下一波能换的，m是n的累加，b是每一波剩下的瓶子的累加。

第一个区别在于，传统法的剩下瓶子总能参与到每一波的对换中，而我的方法每一波总要取3的整数，剩下的要单独最后计算
我的错误就在于，剩下的单独记起来可能是一个较为庞大的数字，而这个数字又必须再次采用这种方法，也就是得嵌套了

不过我直接把剩下的瓶子分为2的倍数去算，即每两瓶换一瓶
而新方法也是这样的，干脆每两瓶换一瓶
那我相当于一半使用旧方法 另一半使用新方法 那为何两个组合起来就是数据错误呢？

因为我有个条件写错了。。。(lll￢ω￢)

在我统计全部剩下来的瓶子之前，循环结束的标识应该是没有可换的杯子了（q=0），但是被我设定成了（q<3）

（丢脸）我明明都把剩余的单拎出来了。。。

然后就因为这个怀疑了好久是不是我没找对思路。。。

附一下我写的非常垃圾的极其新手的代码，也算是做个纪念了

毕竟这是我遇到的第一个基本是我独立打出来而且还挺有挑战性的代码。但他也确实不是很优化。

```c
#include<stdio.h>
//汽水瓶问题
int main()
{
    int p;
    int x[10]={0};
    int i;
    for (i=0; i<10; i++) {
        scanf("%d", &x[i]);
    }
    for (i=0; i<10; i++) 
    {
        int q=0,m=0,n,a,b=0,z,y,ab,bc;
        p = x[i];
        if (p>2)
        {
            q = p;
            while (q!=0)
            {
                n = q/3;
                a = q%3;
                q = n;
                m += n;
                b += a; 
            }
            z = b/2;
            m += z;
            printf("%d\n",m);
        }
        else
        {
            if (p==2)
                printf("3\n");
            if (p==1)
                printf("1\n");
            if (p==0)
                m = 0;
        }
    }
}

```

